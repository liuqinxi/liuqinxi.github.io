<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack tree-shaking</title>
      <link href="/2022/04/27/webpack-tree-shaking/"/>
      <url>/2022/04/27/webpack-tree-shaking/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Tree-shaking"><a href="#什么是Tree-shaking" class="headerlink" title="什么是Tree-shaking?"></a><strong>什么是Tree-shaking?</strong></h3><p>tree-shaking:树摇，打包中去除哪些引入了但是在代码中没有用到的死码，在webpack中js treesharking通过UglifyJSPlugin来进行，css中通过purify-CSS来进行</p><p>tree-sharking针对的是纯的ES模块，才能去除掉那些未使用的代码或成员以及导入的其他模块</p><span id="more"></span><h4 id="什么是纯的ES模块？"><a href="#什么是纯的ES模块？" class="headerlink" title="什么是纯的ES模块？"></a>什么是纯的ES模块？</h4><p>纯ES模块内部或其内部成员不依赖于其他ES模块</p><p>纯ES模块不导入其他非ES模块</p><p>纯ES模块除了导入和导出，没有多余的代码</p><p><strong>作用：减少代码体积</strong></p><p><strong>摇树要不干净怎么解决？</strong></p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606152124154-2140837737.png"></p><p>test.js 中定义了 通过 ES6 模块 暴露了 add 和 count 两个方法，</p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606152836757-2013439339.png">}</p><p>index.js 中 引入了 add 和 count 方法，但是 count 方法的返回值没有使用</p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606153338606-64208927.png"></p><p>![](.&#x2F;webpack-tree-shaking&#x2F;1743698-20200606152257098-494028917 (1).png)</p><p>文件中引入了方法，但是方法的返回值没有使用，webpack编译打包后的js文件中，没有方法的执行，自动去除了没有使用的代码，</p><p>当在package.json中配置“sideEffects”:false时，所有的代码都可以进行tree-sharking,都没有副作用</p><p>但是可能会把css&#x2F;@babel&#x2F;polyfill (副作用)文件去除，</p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606153449160-121978646.png"></p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606152257098-494028917.png"></p><p>避免这种情况，需要重新配置，“sideEffects”:[“<em>.css”,”</em>.less”],过滤这些文件使用tree shaking</p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606153835043-129962384.png"></p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606154016482-466219622.png"></p><p>css文件就保存了</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack_优化</title>
      <link href="/2022/04/27/webpack-%E4%BC%98%E5%8C%96/"/>
      <url>/2022/04/27/webpack-%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack优化：（开发环境和生产环境）"><a href="#webpack优化：（开发环境和生产环境）" class="headerlink" title="webpack优化：（开发环境和生产环境）"></a>webpack优化：（开发环境和生产环境）</h2><h2 id="首先要知道为什么要优化webpack？"><a href="#首先要知道为什么要优化webpack？" class="headerlink" title="首先要知道为什么要优化webpack？"></a>首先要知道为什么要优化webpack？</h2><p>在使用Webpack时，如果不注意性能优化，有非常大的可能会产生性能问题，性能问题主要分为开发时打包构建速度慢、开发调试时的重复性工作、以及输出文件质量不高等，因此性能优化也主要从这些方面来分析。</p><p>​不就是因为在开发阶段可以及时的编译和浏览器实时刷新页面知道最新的内容嘛，   但是如果说模块很多的话  刷新页面这个方案很是不好，加载很慢。</p><h2 id="开发环境优化："><a href="#开发环境优化：" class="headerlink" title="开发环境优化："></a>开发环境优化：</h2><h3 id="优化打包构建速度-HMR"><a href="#优化打包构建速度-HMR" class="headerlink" title="优化打包构建速度 HMR"></a>优化打包构建速度 HMR</h3><p>​HMR 全称 Hot Module Replacement，中文语境通常翻译为模块热更新，它能够在保持页面状态的情况下动态替换资源模块，提供丝滑顺畅的 Web 页面开发体验。</p><span id="more"></span><p>​所以说有一个HMR（热更新，热模块）这个可以让你实时的监听你的文件变化从而达到替换小一部分dom</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="comment">// 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效</span></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./print.js&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。</span></span><br><span class="line">    <span class="comment">// 会执行后面的回调函数</span></span><br><span class="line">    <span class="title function_">print</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化代码调试source-map"><a href="#优化代码调试source-map" class="headerlink" title="优化代码调试source-map"></a>优化代码调试source-map</h3><p>​再思考一个问题 webpack最后打包生成的bundle聚集了所有的代码，如果说其中有一行代码出错了 你是想精准的定位到哪一行还是说不让其有报错</p><p>​设置sourcemap中的属性可以有很多种模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  source-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置</span></span><br><span class="line"><span class="comment">    inline-source-map：内联</span></span><br><span class="line"><span class="comment">      只生成一个内联source-map</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置</span></span><br><span class="line"><span class="comment">    hidden-source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码错误原因，但是没有错误位置</span></span><br><span class="line"><span class="comment">      不能追踪源代码错误，只能提示到构建后代码的错误位置</span></span><br><span class="line"><span class="comment">    eval-source-map：内联</span></span><br><span class="line"><span class="comment">      每一个文件都生成对应的source-map，都在eval</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置</span></span><br><span class="line"><span class="comment">    nosources-source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码准确信息, 但是没有任何源代码信息</span></span><br><span class="line"><span class="comment">    cheap-source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置 </span></span><br><span class="line"><span class="comment">      只能精确的行</span></span><br><span class="line"><span class="comment">    cheap-module-source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置 </span></span><br><span class="line"><span class="comment">      module会将loader的source map加入</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    开发环境：速度快，调试更友好</span></span><br><span class="line"><span class="comment">      速度快(eval&gt;inline&gt;cheap&gt;...)</span></span><br><span class="line"><span class="comment">        eval-cheap-souce-map</span></span><br><span class="line"><span class="comment">        eval-source-map</span></span><br><span class="line"><span class="comment">      调试更友好  </span></span><br><span class="line"><span class="comment">        souce-map</span></span><br><span class="line"><span class="comment">        cheap-module-souce-map</span></span><br><span class="line"><span class="comment">        cheap-souce-map</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      --&gt; eval-source-map  / eval-cheap-module-souce-map</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    生产环境：源代码要不要隐藏? 调试要不要更友好</span></span><br><span class="line"><span class="comment">      内联会让代码体积变大，所以在生产环境不用内联</span></span><br><span class="line"><span class="comment">      nosources-source-map 全部隐藏</span></span><br><span class="line"><span class="comment">      hidden-source-map 只隐藏源代码，会提示构建后代码错误信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      --&gt; source-map / cheap-module-souce-map</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="生产环境中："><a href="#生产环境中：" class="headerlink" title="生产环境中："></a>生产环境中：</h1><h2 id="优化打包构建速度"><a href="#优化打包构建速度" class="headerlink" title="优化打包构建速度"></a>优化打包构建速度</h2><h3 id="oneOf："><a href="#oneOf：" class="headerlink" title="oneOf："></a>oneOf：</h3><p>提升构建速度，避免每个文件都被所有<code>loader</code>过一遍，因为任何一个文件，构建过程中，在遇到第一个与之对应的<code>loader</code>后，不会再往下进行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">oneOf</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;html-loader&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;eslint-loader&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>但是，实际开发过程中，同样会有一个文件需要匹配多个<code>loader</code>的场景，比如<code>js</code>文件同时需要<code>eslint-loader</code>和<code>babel-loader</code>，这样的话就不能将两个<code>loader</code>都放到<code>oneOf</code>里面，因为一旦匹配了第一个<code>loader</code>就不会再继续执行第二个<code>loader</code>，解决办法也很简单，只需要放到<code>oneOf</code>外面即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">enforce</span>: <span class="string">&quot;pre&quot;</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;eslint-loader&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">oneOf</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;html-loader&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="babel缓存："><a href="#babel缓存：" class="headerlink" title="babel缓存："></a>babel缓存：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  缓存：</span></span><br><span class="line"><span class="comment">    babel缓存</span></span><br><span class="line"><span class="comment">      cacheDirectory: true</span></span><br><span class="line"><span class="comment">      --&gt; 让第二次打包构建速度更快</span></span><br><span class="line"><span class="comment">    文件资源缓存</span></span><br><span class="line"><span class="comment">      hash: 每次wepack构建时会生成一个唯一的hash值。</span></span><br><span class="line"><span class="comment">        问题: 因为js和css同时使用一个hash值。</span></span><br><span class="line"><span class="comment">          如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）</span></span><br><span class="line"><span class="comment">      chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样</span></span><br><span class="line"><span class="comment">        问题: js和css的hash值还是一样的</span></span><br><span class="line"><span class="comment">          因为css是在js中被引入的，所以同属于一个chunk</span></span><br><span class="line"><span class="comment">      contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样    </span></span><br><span class="line"><span class="comment">      --&gt; 让代码上线运行缓存更好使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">                <span class="attr">presets</span>: [</span><br><span class="line">                    [</span><br><span class="line">                        <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">                            <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">                            <span class="attr">targets</span>: &#123;</span><br><span class="line">                                <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                                <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                ],</span><br><span class="line">                <span class="comment">// 开启babel缓存</span></span><br><span class="line">                <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">                <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            <span class="attr">use</span>: [</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                开启多进程打包。 </span></span><br><span class="line"><span class="comment">                进程启动大概为600ms，进程通信也有开销。</span></span><br><span class="line"><span class="comment">                只有工作消耗时间比较长，才需要多进程打包</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">workers</span>: <span class="number">2</span> <span class="comment">// 进程2个</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">presets</span>: [</span><br><span class="line">                            [</span><br><span class="line">                                <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">                                    <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">                                    <span class="attr">targets</span>: &#123;</span><br><span class="line">                                        <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                                        <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="comment">// 开启babel缓存</span></span><br><span class="line">                        <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">                        <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">externals</span>: &#123;</span><br><span class="line">  <span class="comment">// 拒绝jQuery被打包进来</span></span><br><span class="line">  <span class="attr">jquery</span>: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要引用一个库，但是又不想让webpack打包（减少打包的时间），并且又不影响我们在程序中以<a href="https://so.csdn.net/so/search?q=CMD&spm=1001.2101.3001.7020">CMD</a>、AMD或者window&#x2F;global全局等方式进行使用（一般都以import方式引用使用），那就可以通过配置externals。</p><p>这样做的目的就是<strong>将不怎么需要更新的第三方库脱离webpack打包，不被打入bundle中，从而减少打包时间，但又不影响运用第三方库的方式，例如import方式等。</strong></p><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><ul><li><p>什么是DLL</p><ul><li>DLL全称是动态链接库(Dynamic Link Library)，是为软件在Windows中实现共享函数库的一种实现方式;</li><li>那么webpack中也有内置DLL的功能，它指的是可以将可以共享，并且不经常改变的代码，抽取成一个共享的库;</li><li>这个库在之后编译的过程中，会被引入到其他项目的代码中，减少的打包的时间;</li></ul></li><li><p>DDL库的使用分为两步:</p><ul><li><p>第一步:打包一个DLL库; </p><p><strong>webpack –config webpack.dll.js</strong></p></li><li><p>第二步:项目中引入DLL库</p><p><strong>webpack</strong></p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.js</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包</span></span><br><span class="line"><span class="comment">    当你运行 webpack 时，默认查找 webpack.config.js 配置文件</span></span><br><span class="line"><span class="comment">    需求：需要运行 webpack.dll.js 文件</span></span><br><span class="line"><span class="comment">      --&gt; webpack --config webpack.dll.js</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="comment">// 最终打包生成的[name] --&gt; jquery</span></span><br><span class="line">    <span class="comment">// [&#x27;jquery&#x27;] --&gt; 要打包的库是jquery</span></span><br><span class="line">    <span class="attr">jquery</span>: [<span class="string">&#x27;jquery&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dll&#x27;</span>),</span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span> <span class="comment">// 打包的库里面向外暴露出去的内容叫什么名字</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 打包生成一个 manifest.json --&gt; 提供和jquery映射</span></span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>, <span class="comment">// 映射库的暴露的内容名称</span></span><br><span class="line">      <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>) <span class="comment">// 输出文件路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AddAssetHtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 告诉webpack哪些库不参与打包，同时使用时的名称也得变~</span></span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">      <span class="attr">manifest</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 将某个文件打包输出去，并在html中自动引入该资源</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AddAssetHtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filepath</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dll/jquery.js&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="优化代码运行的性能"><a href="#优化代码运行的性能" class="headerlink" title="优化代码运行的性能"></a>优化代码运行的性能</h2><h3 id="缓存-hash-chunkhash-contenthash"><a href="#缓存-hash-chunkhash-contenthash" class="headerlink" title="缓存(hash-chunkhash-contenthash)"></a>缓存(hash-chunkhash-contenthash)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash</span>: 每次wepack构建时会生成一个唯一的hash值。</span><br><span class="line">  问题: 因为js和css同时使用一个hash值。</span><br><span class="line">    如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）</span><br><span class="line">chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样</span><br><span class="line">  问题: js和css的hash值还是一样的</span><br><span class="line">    因为css是在js中被引入的，所以同属于一个chunk</span><br><span class="line"><span class="attr">contenthash</span>: 根据文件的内容生成hash值。不同文件hash值一定不一样 </span><br></pre></td></tr></table></figure><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  tree shaking：去除无用代码</span></span><br><span class="line"><span class="comment">    前提：1. 必须使用ES6模块化  2. 开启production环境</span></span><br><span class="line"><span class="comment">    作用: 减少代码体积</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在package.json中配置 </span></span><br><span class="line"><span class="comment">      &quot;sideEffects&quot;: false 所有代码都没有副作用（都可以进行tree shaking）</span></span><br><span class="line"><span class="comment">        问题：可能会把css / @babel/polyfill （副作用）文件干掉</span></span><br><span class="line"><span class="comment">      &quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="code-split"><a href="#code-split" class="headerlink" title="code split"></a>code split</h3><p>当使用 webpack 打包 JavaScript 文件的时候，依赖了第三方库，比如 有两个入口：testa，testb，  都依赖了 jQuery，jQuery就会被打包到这两个文件中，显然这是不太合理的，应该是 jQuery 单独打包一个文件，然后 testa 和 testb 分别引入。</p><p>方式一：</p><p>通过配置多入口，打包成多个文件</p><p>方式二：</p><p>动态引入 (dynamic import) JavaScript 文件必然会单独打包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 /*webpackChunkName:lodash*/ 给构建出的chunk命名，否则会以构建id命名。</span></span><br><span class="line"><span class="title function_">import</span>(<span class="comment">/*webpackChunkName:&#x27;lodash&#x27;*/</span><span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(params) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 导入成功</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="string">&#x27;An error occurred while loading the component&#x27;</span>); </span><br></pre></td></tr></table></figure><p>方式三：</p><p>配置webpack的code split  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/index.js&#x27;</span>),</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> webpack.<span class="title class_">HashedModuleIdsPlugin</span>() <span class="comment">// 根据模块的相对路径生成 HASH 作为模块 ID</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">runtimeChunk</span>: <span class="string">&#x27;single&#x27;</span>,</span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">// 默认 async 可选值 all 和 initial</span></span><br><span class="line">            <span class="attr">maxInitialRequests</span>: <span class="title class_">Infinity</span>, <span class="comment">// 一个入口最大的并行请求数</span></span><br><span class="line">            <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 避免模块体积过小而被忽略</span></span><br><span class="line">            <span class="attr">minChunks</span>: <span class="number">1</span>, <span class="comment">// 默认也是一表示最小引用次数</span></span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">                <span class="attr">vendor</span>: &#123;</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 如果需要的依赖特别小，可以直接设置成需要打包的依赖名称</span></span><br><span class="line">                    <span class="title function_">name</span>(<span class="params"><span class="variable language_">module</span>, chunks, chcheGroupKey</span>) &#123; <span class="comment">// 可提供布尔值、字符串和函数，如果是函数，可编写自定义返回值</span></span><br><span class="line">                        <span class="keyword">const</span> packageName = <span class="variable language_">module</span>.<span class="property">context</span>.<span class="title function_">match</span>(<span class="regexp">/[\\/]node_modules[\\/](.*?)([\\/]|$)/</span>)[<span class="number">1</span>] <span class="comment">// 获取模块名称</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">`npm.<span class="subst">$&#123;packageName.replace(<span class="string">&#x27;@&#x27;</span>, <span class="string">&#x27;&#x27;</span>)&#125;</span>`</span> <span class="comment">// 可选，一般情况下不需要将模块名称 @ 符号去除</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒加载-x2F-预加载"><a href="#懒加载-x2F-预加载" class="headerlink" title="懒加载&#x2F;预加载"></a>懒加载&#x2F;预加载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒加载~：当文件需要使用时才加载~</span></span><br><span class="line"><span class="comment">// 预加载 prefetch：会在使用之前，提前加载js文件 </span></span><br><span class="line"><span class="comment">// 正常加载可以认为是并行加载（同一时间加载多个文件）  </span></span><br><span class="line"><span class="comment">// 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源   </span></span><br><span class="line"><span class="comment">// 魔法注释 webpackPrefetch: true  开启预加载</span></span><br><span class="line"><span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27;, webpackPrefetch: true */</span><span class="string">&#x27;./test&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mul</span>(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端打包工具</title>
      <link href="/2022/04/27/%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/04/27/%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack，grunt-gulp-vite-fis3-Rollup-Pacel？"><a href="#webpack，grunt-gulp-vite-fis3-Rollup-Pacel？" class="headerlink" title="webpack，grunt,gulp,vite,fis3,Rollup,Pacel？"></a>webpack，grunt,gulp,vite,fis3,Rollup,Pacel？</h2><p><strong>webpack:</strong></p><p>就目前而言，weboack是最常用的打包工具，基于入口，webpack会自动递归解析入口所需要的所有资源，然后不同的loader处理不同的文件，用plugin来扩展webpack功能</p><p><strong>gulp:</strong></p><span id="more"></span><p>gulp是前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task.自动化构建工具并不能把所有的模块打包，也不能构建不同模块之间的依赖关系</p><p><strong>grunt:</strong></p><p>基于任务和流的，类似于jQuery,找到一个文件，对其做 一系列的链式操作，更新流上的数据，整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程</p><p><strong>Rollup:</strong></p><p>是一款ES Modules打包器，从作用上来看，Rollup与webpack非常类似，不过相比于webpack，Rollup要小巧的多，专门打包js</p><p>我们熟知的库都是用他进行打包，比如：vue,react等</p><p><strong>Parcel:</strong></p><p>是一款完全零配置的前端打包器，它提供了傻瓜式的使用体验，只需要了解简单的命令，就能构建前端应用程序</p><p>Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用 HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。</p><p><strong>vite:</strong></p><p>是vue作者尤雨溪开发的web开发构建工具，基于浏览器原生es模块导入的开发服务器，在开发环境下，利用浏览器去解析import,在服务器按需编译返回，完全跳过打包的概念，服务器随启随用，同时不仅对vue提供了支持，还支持热更新，热更新的速度不会随着模块增多而变慢。</p><p>特点：- 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译</p><p><strong>fis3:</strong></p><p>百度研发的，静态资源动态按需加载。</p><h4 id="webpack-Rollup-Pacel区别？"><a href="#webpack-Rollup-Pacel区别？" class="headerlink" title="webpack Rollup Pacel区别？"></a>webpack Rollup Pacel区别？</h4><table><thead><tr><th>对比</th><th>Webpack</th><th>Rollup</th><th>Parcel</th></tr></thead><tbody><tr><td>功能</td><td>为处理资源管理和分割代码而生，可以用来处理任何类型的文件，灵活，插件多。</td><td>用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。</td><td>用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。</td></tr><tr><td>配置</td><td>webpack需要配config文件，指明entry, output, plugin，transformations。</td><td>rollup需要配config文件，指明entry, output, plugin，transformations。rollup 有对import&#x2F;export所做的node polyfills，webpack没有。rollup支持相对路径，而webpack没有，所以得使用</td><td>parcel则是完全开箱可用的，不用配置。</td></tr><tr><td>入口文件</td><td>webpack只支持js文件作为入口文件，如果要以其他格式的文件作为入口，比如html文件为入口，如要加第三方Plugin。</td><td>rollup可以用html作为入口文件，但也需要plugin，比如rollup-plugin-html-entry。</td><td>parcel可以用index.html作为入口文件，而且它会通过看index.html的script tag里包含的什么自己找到要打包生成哪些js文件。</td></tr><tr><td>transformations</td><td>transformations指的是把其他文件转化成js文件的过程，需要经过transformation才能够被打包。webpack使用Loaders来处理。</td><td>rollup使用plugins来处理。</td><td>parcel会自动去转换，当找到配置文件比如.babelrc, .postcssrc后就会自动转。</td></tr><tr><td>摇树优化</td><td>摇树优化是webpack的一大特性。需要1，用import&#x2F;export语法，2，在package.json中加副作用的入口，3，加上支持去除死代码的缩小器（uglifyjsplugin）。</td><td>rollup会统计引入的代码并排除掉那些没有被用到的。这使您可以在现有工具和模块的基础上构建，而无需添加额外的依赖项或膨胀项目的大小。</td><td>parcel不支持摇树优化。</td></tr><tr><td>dev server</td><td>webpack用webpack-dev-server。</td><td>rollup用rollup-plugin-serve和rollup-plugin-livereload共同作用。</td><td>parcel内置的有dev server</td></tr><tr><td>热更新</td><td>webpack的 wepack-dev-server支持hot模式。</td><td>rollup不支持hmr。</td><td>parcel有内置的hmr。</td></tr><tr><td>代码分割</td><td>webpack通过在entry中手动设置，使用CommonsChunkPlugin，和模块内的内联函数动态引入来做代码分割。</td><td>rollup有实验性的代码分割特性。它是用es模块在浏览器中的模块加载机制本身来分割代码的。需要把experimentalCodeSplitting 和 experimentalDynamicImport 设为true。</td><td>parcel支持0配置的代码分割。主要是通过动态improt。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端打包工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端打包工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack_proxy</title>
      <link href="/2022/04/27/webpack-proxy/"/>
      <url>/2022/04/27/webpack-proxy/</url>
      
        <content type="html"><![CDATA[<h4 id="Webpack-Proxy工作原理"><a href="#Webpack-Proxy工作原理" class="headerlink" title="Webpack Proxy工作原理"></a>Webpack Proxy工作原理</h4><p>webpack proxy，即webpack提供的代理服务，解决前端跨域的方法。</p><p>基本行为就是接收客户端发送的请求后转发给目标服务器、</p><p>其目的就是为了便于开发者在开发模式下解决跨域的问题。</p><p>想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server</p><h3 id="proxy工作原理："><a href="#proxy工作原理：" class="headerlink" title="proxy工作原理："></a>proxy工作原理：</h3><p>实质就是通过http-proxy-middleware这个http代理中间件，实现请求转发给目标服务器。</p><h3 id="跨域："><a href="#跨域：" class="headerlink" title="跨域："></a>跨域：</h3><span id="more"></span><p>在开发阶段，webpack-dev-server会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在localhost的一个端口上，而后端服务器又是运行在另一个地址上，所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端会出现跨域请求问题，</p><p>解决跨域，需要设置webpack proxy代理，</p><p>当本地发送请求的时候，代理服务器响应 该请求，并将请求转发到目标服务器，目标服务器响应数据后在将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>plugin</title>
      <link href="/2022/04/27/plugin/"/>
      <url>/2022/04/27/plugin/</url>
      
        <content type="html"><![CDATA[<h3 id="plugin是什么-x2F-作用？"><a href="#plugin是什么-x2F-作用？" class="headerlink" title="plugin是什么&#x2F;作用？"></a>plugin是什么&#x2F;作用？</h3><p>plugin是插件的意思，通常用于对某个现有的架构进行扩展。webpack整体的程序架构也是基于插件系统之上搭建的，plugin的目的在于解决loader无法实现的其他功能，比如打包优化、文件压缩等。</p><h3 id="常见的plugin"><a href="#常见的plugin" class="headerlink" title="常见的plugin?"></a>常见的plugin?</h3><ul><li>define-plugin定义环境变量</li><li>commons-weboack-plugin:提取公共代码</li><li>uglifyjs-webpack-plugin:通过UglifyES压缩es6代码</li><li>purgecss-webpack-plugin:擦除无用css</li><li>happypack:多线程处理打包</li><li>webpack-bundle-analyzer:打包分析</li><li>speed-measure-webpack-plugin:构建速度分析</li><li>html-webpack-plugin:为html文件引入的外部资源如script,link动态添加每次complie后的hash,防止引用缓存的外部文件问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack  Loader</title>
      <link href="/2022/04/27/loader/"/>
      <url>/2022/04/27/loader/</url>
      
        <content type="html"><![CDATA[<h3 id="loader是什么？"><a href="#loader是什么？" class="headerlink" title="loader是什么？"></a>loader是什么？</h3><p>webpack只能理解JavaScript和Json文件，这是webpack开箱可用的自带能力。</p><p>loader可以让webpack能够去处理其他类型的文件，比如.scss和.ts，并将他们转换为有效的功能离散的chunk文件以供 应用程序使用，以及被添加到依赖图中，也可以将内联图转换为data URL。简单来说：loader可以将一段代码转换成另一段代码。</p><p>loader从下到上取值，也就是从后往前执行，从ts-loader开始执行，然后继续执行css-loader,最后以raw-loader结束。</p><p>loader有两个属性：test,正则表达式，用于识别出哪些文件会被转换，</p><p>​                                use,定义在进行转换时应该使用哪个loader，可以是字符串，数组和对象。</p><span id="more"></span><h3 id="loader机制的作用是什么？"><a href="#loader机制的作用是什么？" class="headerlink" title="loader机制的作用是什么？"></a>loader机制的作用是什么？</h3><p>webpack只能理解JavaScript和Json文件，而loader为webpack添加了处理其他类型的文件的能力。</p><p>webpack在配置里的module.rules数组配置了一组规则，告诉webapck在遇到哪些文件时使用哪些loader去加载和转换打包成js。</p><h3 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h3><ul><li>file-loader:把文件输出到一个文件夹中，在代码中通过相对的URL去引用输出的文件</li><li>url-loader:和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中</li><li>source-map-loader:加载额外的Source Map文件，以方便断点调试</li><li><strong>image-loader:加载并压缩图片文件</strong></li><li><strong>babel-loader:把es6转换成es5</strong></li><li><strong>css-loader:加载css,支持模块化，压缩，文件导入等特性</strong></li><li><strong>style-loader:把css代码注入到JavaScript中，通过DOM操作去加载css</strong></li><li><strong>eslint-loader:通过eslint检查JavaScript代码</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack4和webpack5的区别</title>
      <link href="/2022/04/26/webpack4-5/"/>
      <url>/2022/04/26/webpack4-5/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack4和webpack5的区别？"><a href="#webpack4和webpack5的区别？" class="headerlink" title="webpack4和webpack5的区别？"></a>webpack4和webpack5的区别？</h2><h5 id="1、Tree-Shaking-强大"><a href="#1、Tree-Shaking-强大" class="headerlink" title="1、Tree Shaking(强大)"></a>1、Tree Shaking(强大)</h5><p>tree-shaking 就可以把没有用的那些东西剔除掉，来大大减少最终的bundle体积。</p><ul><li>usedExports : true, 标记没有用的叶子</li><li>minimize: true, 摇掉那些没有用的叶子</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js中</span></span><br><span class="line"></span><br><span class="line"> <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line"></span><br><span class="line">      <span class="attr">usedExports</span>: <span class="literal">true</span>, <span class="comment">//只导出被使用的模块</span></span><br><span class="line"></span><br><span class="line">      minimize : <span class="literal">true</span> <span class="comment">// 启动压缩</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="2-压缩代码"><a href="#2-压缩代码" class="headerlink" title="2.压缩代码"></a>2.压缩代码</h5><p>webpack4 上需要下载安装 terser-webpack-plugin 插件</p><p>webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js中</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"></span><br><span class="line">     <span class="attr">optimization</span>: &#123;</span><br><span class="line"></span><br><span class="line">       <span class="attr">usedExports</span>: <span class="literal">true</span>, <span class="comment">//只导出被使用的模块</span></span><br><span class="line"></span><br><span class="line">       minimize : <span class="literal">true</span> <span class="comment">// 启动压缩</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="3-缓存配置"><a href="#3-缓存配置" class="headerlink" title="3.缓存配置"></a>3.缓存配置</h5><p>webpack4 缓存配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install hard-source-webpack-plugin -D</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HardSourceWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;hard-source-webpack-plugin&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; </span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="comment">// 其它 plugin... </span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HardSourceWebpackPlugin</span>(), </span><br><span class="line">] &#125;</span><br></pre></td></tr></table></figure><p>webpack5 缓存配置</p><p>webpack5 内部内置了 cache 缓存机制。直接配置即可。</p><p>cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>= &#123;</span><br><span class="line">  <span class="comment">// 使用持久化缓存</span></span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;filesystem&#x27;</span>，</span><br><span class="line">    <span class="attr">cacheDirectory</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;node_modules/.cac/webpack&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-启动服务的差别"><a href="#4-启动服务的差别" class="headerlink" title="4.启动服务的差别"></a>4.启动服务的差别</h5><p>webpack4 启动服务<br>    通过 webpack-dev-server 启动服务</p><p>webpack5 启动服务<br>内置使用 webpack serve 启动，但是他的日志不是很好，所以一般喜欢用 webpack-dev-server 优化</p><h5 id="5-打包"><a href="#5-打包" class="headerlink" title="5.打包"></a>5.打包</h5><p>webpack4打包:即使后续没有使用到的函数，依然会将代码打包进去</p><p>webpack5打包:后续没有使用到的函数，不会将代码打包进去</p><h5 id="6-输出代码"><a href="#6-输出代码" class="headerlink" title="6.输出代码"></a>6.输出代码</h5><p>webpack4只能输出es5的代码</p><p>webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码</p><h5 id="7-分割代码块（splitChunk）"><a href="#7-分割代码块（splitChunk）" class="headerlink" title="7.分割代码块（splitChunk）"></a>7.分割代码块（splitChunk）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack4将超过30kb的文件单独提为一个chunk</span></span><br><span class="line"><span class="attr">minSize</span>: <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack5可以区分是js还是css,可以精确划分</span></span><br><span class="line"><span class="attr">minSize</span>:&#123;<span class="attr">javascript</span>:<span class="number">30000</span>,<span class="attr">css</span>:<span class="number">50000</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识webpack</title>
      <link href="/2019/04/14/webpack/"/>
      <url>/2019/04/14/webpack/</url>
      
        <content type="html"><![CDATA[<h4 id="webpack是什么？"><a href="#webpack是什么？" class="headerlink" title="webpack是什么？"></a>webpack是什么？</h4><p>webpack是前端资源加载&#x2F;打包的工具，他根据模块的依赖关系进行静态分析，然后根据指定的规则生成静态资源。</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>webapck可以将多种静态资源js,css,html等转换成一个静态文件，减少页面请求。</p><h4 id="核心概念："><a href="#核心概念：" class="headerlink" title="核心概念："></a>核心概念：</h4><p>1：entry:指定入口，打包的时候告诉webpack从哪个文件开始打包</p><p>2：output:指定出口，打包后的文件指定输出路径和文件名，将文件写入文件系统</p><p>3：loader:转换器，简单来说就是将一段代码转换成另一段代码，webpack只能解析JavaScript代码，将代码转换成webpack能解析的JavaScript</p><p>4：plugin:插件，可以用于范围更广的任务，完成loader不能完成的任务，比如代码优化和压缩等</p><p>5：mode：模式，null,development(开发模式)，production(生产模式)</p><span id="more"></span><h4 id="构建流程："><a href="#构建流程：" class="headerlink" title="构建流程："></a>构建流程：</h4><p>1：初始化参数：将配置文件和命令中的参数合并读取，将参数进行初始化，得到最终的参数</p><p>2：开始编译：得到最终的参数实例化complier对象，加载配置文件plugin,执行run方法进行编译</p><p>3：确定入口：从entry入口找到所有的入口文件，递归遍历所有的文件</p><p>4：编译模块：从入口文件出发，调用所有的配置loader对模块进行编译，模块找出依赖的模块，递归编译直到所有的文件都进行了编译</p><p>5：输出资源：所有的模块都编译完成，得到最终的输出资源，chunk</p><p>6：确定输出：将得到的最终资源，chunk,配置输出文件的路径和文件名，将文件输出文件系统</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

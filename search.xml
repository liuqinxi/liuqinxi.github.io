<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue和react技术选型</title>
      <link href="/2022/04/30/vue%E5%92%8Creact%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
      <url>/2022/04/30/vue%E5%92%8Creact%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="vue和react技术选型？"><a href="#vue和react技术选型？" class="headerlink" title="vue和react技术选型？"></a>vue和react技术选型？</h2><p>相同点：</p><ol><li>数据驱动页面，提供响应式的视图组件</li><li>都有虚拟DOM，组件化的开发，通过props参数进行父子之间的组件传递数据，都是先了webComponents规范</li><li>数据流动单向，都支持服务器的渲染的SSR</li><li>都有支持native的方法，react有React native,vue 有vuex</li></ol><p>不同点：</p><ol><li>数据绑定：vue实现了双向的数据绑定，react数据流动是单向的</li><li>数据渲染：大规模的数据渲染，，react更快</li><li>使用场景：react配合redux架构适合大规模多人协作复杂项目，vue适合小快的项目</li><li>开发风格：react推荐做法jsx+inline style把html和css都写在js了，vue采用的式webpack+vue-loader单文件组件格式，html,js,css同一文件。</li></ol><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>nextTick可以让我们在<strong>下次DOM更新循环结束之后执行延迟回调</strong>，用于获得更新后的DOM</p><p>nextTIck主要使用了宏任务和微任务，根据执行环境分别尝试采用</p><p>promise</p><p>MutatuionObserver</p><p>serTimmediate</p><p>如果以上都不行，采用setTimeout</p><p>定义一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvvm框架</title>
      <link href="/2022/04/30/mvvm%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/04/30/mvvm%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="mvvm框架："><a href="#mvvm框架：" class="headerlink" title="mvvm框架："></a>mvvm框架：</h2><p>m:数据模型，可以在model中定义数据修改和操作的业务逻辑</p><p>v:视图，代表UI组件，复杂将数据模型转化成UI展现出来</p><p>vm:视图模型，是一个同步view和model的对象</p><p>view的变化会自动更新到viewModel，viewModel的变化也会自动同步到view上显示，这种自动同步是因为viewModel中的属性实现了Observer，当属性变更时都能出发对应的操作。</p><p>开发者只需要关注业务逻辑，不需要手动操作DOM,不需关注数据状态的同步问题，复杂的数据完全由MVVM来统一管理。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>高内聚，低耦合，可重用性，独立开发，可测试</p><p>1、低耦合： 视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同 </p><p>的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 </p><p>2、可重用性： 你可以把一些视图逻辑放在一个ViewModel里面，让很多 view 重用这段视图逻辑。 </p><p>3、独立开发： 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设 </p><p>计。 </p><p>4、可测试： 界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p><h3 id="常见的实现MVVM数据绑定的做法有哪些？"><a href="#常见的实现MVVM数据绑定的做法有哪些？" class="headerlink" title="常见的实现MVVM数据绑定的做法有哪些？"></a>常见的实现MVVM数据绑定的做法有哪些？</h3><h4 id="1：发布者-订阅者模式："><a href="#1：发布者-订阅者模式：" class="headerlink" title="1：发布者-订阅者模式："></a>1：发布者-订阅者模式：</h4><p>一般通过sub,pub的方式实现数据和视图的绑定监听</p><p>更新数据的饭时通常做法时vm.set(“property”,value)</p><h4 id="2：脏值检查："><a href="#2：脏值检查：" class="headerlink" title="2：脏值检查："></a>2：脏值检查：</h4><p>angular.js是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，</p><p>最简单的方式就是通过setInterval()定时轮询检测数据变动</p><p>angular只有在指定的事件触发时进入脏值检测</p><p>1、DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) </p><p>2、XHR响应事件 ( $http ) </p><p>3、浏览器Location变更事件 ( $location ) </p><p>4、Timer事件( $timeout , $interval ) </p><p>5、执行 $digest() 或 $apply()</p><h4 id="3：数据劫持"><a href="#3：数据劫持" class="headerlink" title="3：数据劫持"></a>3：数据劫持</h4><p>vue.js则是采用数据接劫持结合发布者-订阅者模式的方式，通过object.dfineProperty()来劫持各个属性的setter,getter在数据变动时发布消息给订阅者，触发相应的监听回调。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用方法</title>
      <link href="/2022/04/29/hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/04/29/hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是hexo？"><a href="#什么是hexo？" class="headerlink" title="什么是hexo？"></a>什么是hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h4 id="hexo指令"><a href="#hexo指令" class="headerlink" title="hexo指令"></a>hexo指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h4 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> hexo new [layout] &lt;title&gt;</span><br><span class="line"> //或</span><br><span class="line"> </span><br><span class="line">hexo n &#x27;新建&#x27;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>安装完成后，输入以下命令以启动服务器，您的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">//或</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="上传服务器"><a href="#上传服务器" class="headerlink" title="上传服务器"></a>上传服务器</h4><p>先清除本地缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布订阅模式和观察者模式</title>
      <link href="/2022/04/28/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/28/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h3><h4 id="1-发布-x2F-订阅模式"><a href="#1-发布-x2F-订阅模式" class="headerlink" title="1:发布&#x2F;订阅模式"></a>1:发布&#x2F;订阅模式</h4><p>发布&#x2F;订阅模式</p><ul><li>订阅者</li><li>发布者</li><li>信号中心</li></ul><p>我们假定，存在一个“信号中心”，某个任务执行完成，就像信号中心“发布（publish）”一个信号，其他任务可以香、像信号中心“订阅（subscribe）”这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布&#x2F;订阅模式”（publish-subscribe pattern）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="comment">// 事件中心</span></span><br><span class="line"><span class="keyword">let</span> eventHub = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentA.vue</span></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="attr">addTodo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 发布消息(事件)</span></span><br><span class="line">  eventHub.$emit(<span class="string">&#x27;add-todo&#x27;</span>, &#123; <span class="attr">text</span>: <span class="variable language_">this</span>.<span class="property">newTodoText</span> &#125;) </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newTodoText</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ComponentB.vue</span></span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 订阅消息(事件)</span></span><br><span class="line">  eventHub.$on(<span class="string">&#x27;add-todo&#x27;</span>, <span class="variable language_">this</span>.<span class="property">addTodo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-观察者模式"><a href="#2-观察者模式" class="headerlink" title="2. 观察者模式"></a><strong>2. 观察者模式</strong></h4><ul><li><p>观察者（订阅者）–watcher</p><p>​update():当事件发生是，具体要做的事情</p></li><li><p>目标（发布者）–Dep</p><p>​subs数组：存储所有的观察者</p><p>​addSub():添加观察者</p><p>​notify():当事件发生，调用所有的观察者的update()方法</p></li><li><p>没有事件中心</p></li></ul><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a><strong>3. 总结</strong></h4><ul><li><strong>观察者模式</strong>是由具体目标调度，比如当事件触发，<code>Dep</code> 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的</li><li><strong>发布&#x2F;订阅模式</strong>由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在</li></ul><p><img src="/2022/04/28/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/20210328214834.png"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3响应式原理</title>
      <link href="/2022/04/28/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2022/04/28/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="vue3响应式原理？"><a href="#vue3响应式原理？" class="headerlink" title="vue3响应式原理？"></a>vue3响应式原理？</h3><p>vue3改用proxy替代Object.defineProperty,因为Proxy可以直接监听对象和数组的变化，并且有多达13中拦截方式，并且作为新标准将受到浏览器厂商重点持续的性能优化。</p><h5 id="Proxy只会代理对象的第一层，那么vue3又怎样处理这个问题呢？"><a href="#Proxy只会代理对象的第一层，那么vue3又怎样处理这个问题呢？" class="headerlink" title="Proxy只会代理对象的第一层，那么vue3又怎样处理这个问题呢？"></a>Proxy只会代理对象的第一层，那么vue3又怎样处理这个问题呢？</h5><p>判断当前Reflect.get的返回值是否为Object，如果是则在通过reactive方法做代理，这样就实现了深度观测。</p><h5 id="监测数组的时候可能触发多次get-x2F-set，那么如何防止触发多次呢？"><a href="#监测数组的时候可能触发多次get-x2F-set，那么如何防止触发多次呢？" class="headerlink" title="监测数组的时候可能触发多次get&#x2F;set，那么如何防止触发多次呢？"></a>监测数组的时候可能触发多次get&#x2F;set，那么如何防止触发多次呢？</h5><p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值是否相等，只有满足以上两个条件之一时，才有可能执行trigger</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 Vue 中的 data 选项 </span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟 Vue 实例</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 当访问 vm 的成员会执行</span></span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get, key: &#x27;</span>, key, target[key])</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当设置 vm 的成员会执行</span></span><br><span class="line">  set (target, key, newValue) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set, key: &#x27;</span>, key, newValue)</span><br><span class="line">    <span class="keyword">if</span> (target[key] === newValue) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = newValue</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">vm.<span class="property">msg</span> = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">msg</span>)</span><br></pre></td></tr></table></figure><h4 id="Proxy-相比于-defineProperty-的优势"><a href="#Proxy-相比于-defineProperty-的优势" class="headerlink" title="Proxy 相比于 defineProperty 的优势"></a><strong>Proxy 相比于 defineProperty 的优势</strong></h4><p>数组变化能监听到</p><p>不需要深度遍历监听</p><p>proxy是es6种新增的功能，可以用来自定义对象中的操作</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="/2022/04/28/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/20210408091523.png"></p><ul><li><p>Vue</p><ul><li>记录传入的选项，设置 <code>$data/$el</code></li><li>把 <code>data</code> 的成员注入到 <code>Vue</code> 实例</li><li>负责调用 <code>Observer</code> 实现数据响应式处理(数据劫持)</li><li>负责调用 <code>Compiler</code> 编译指令&#x2F;插值表达式等</li></ul></li><li><pre><code>Observer<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 数据劫持</span><br><span class="line">    - 负责把 `data` 中的成员转换成 `getter/setter`</span><br><span class="line">    - 负责把多层属性转换成 `getter/setter`</span><br><span class="line">    - 如果给属性赋值为新对象，把新对象的成员设置为 `getter/setter`</span><br><span class="line">  - 添加 `Dep` 和 `Watcher` 的依赖关系</span><br><span class="line">  - 数据变化发送通知</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  Compiler</span><br></pre></td></tr></table></figure>- 负责编译模板，解析指令/插值表达式- 负责页面的首次渲染过程- 当数据变化后重新渲染</code></pre></li><li><p>&#96;&#96;&#96;<br>Dep</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 收集依赖，添加订阅者(`watcher`)</span><br><span class="line">  - 通知所有订阅者</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  Watcher</span><br></pre></td></tr></table></figure><ul><li>自身实例化的时候往<code>dep</code>对象中添加自己</li><li>当数据变化<code>dep</code>通知所有的 <code>Watcher</code> 实例更新视图</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue响应式原理</title>
      <link href="/2022/04/28/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2022/04/28/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="vue是什么？"><a href="#vue是什么？" class="headerlink" title="vue是什么？"></a>vue是什么？</h3><p>vue是构建用户界面的<strong>渐进式框架</strong>。vue被设计为可以自底向上逐层应用。vue的核心库只关心视图层，不仅容易上手，还便于与第三方库或既有项目整合。</p><h3 id="vue特性？"><a href="#vue特性？" class="headerlink" title="vue特性？"></a>vue特性？</h3><p>数据驱动：双向绑定<br>Vue.js数据观测原理在技术实现上，利用的是ES5Object.defineProperty和存储器属性: getter和 </p><p>setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即 </p><p>ViewModel，保证数据和视图的一致性。</p><p>组件化：</p><p>1、模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。 </p><p>2、初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状 </p><p>态。 </p><p>3、接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。 </p><p>4、方法（methods）：对数据的改动操作一般都在组件的方法内进行。 </p><p>5、生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新2.0版本 </p><p>对于生命周期函数名称改动很大。 </p><p>6、私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。一个组 </p><p>件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。</p><h3 id="vue响应式原理？"><a href="#vue响应式原理？" class="headerlink" title="vue响应式原理？"></a>vue响应式原理？</h3><p>vue响应式原理的核心是通过ES5的保护对象的Object.defindeProperty中的访问器属性中的get和set方法，data中声明的属性都被添加了访问器属性，当读取data中的数据时自动调用get方法，当修改data中的数据时，自动调用set方法，检测到数据的变化，会通知观察者wacher,观察者wacher自动触发重新render当前组件（子组件不会重新渲染），生成新的虚拟DOM树，vue框架会遍历并对比新虚拟DOM树和旧虚拟DOM树种的每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实DOM书上。</p><p><img src="/2022/04/28/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/vue%E5%8E%9F%E7%90%86.png"></p><p>因为只要在data中声明的基本数据类型的数据，基本不存在数据不响应的问题，所以重点介绍数据和对象在vue中的数据响应问题，vue可以检测对象属性的修改，但无法监听数组的所有变动及对象的新增和删除，只能使用数组编译方法及$set方法。</p><p>总结：</p><p>vue采用数据劫持结合发布–订阅模式的方法，通过Object.defineProperty()来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><h3 id="Object-defineProperty-，那么它的用法是什么，以及优缺点是什么呢？"><a href="#Object-defineProperty-，那么它的用法是什么，以及优缺点是什么呢？" class="headerlink" title="**Object.defineProperty()**，那么它的用法是什么，以及优缺点是什么呢？"></a>**Object.defineProperty()**，那么它的用法是什么，以及优缺点是什么呢？</h3><p>可以检测对象中数据发生的修改</p><p>对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是他的缺点</p><p>对于一个对象中，如果你新增加属性，删除属性，Object.defineProperty()是不能观测到的，那么应该如何解决呢？</p><p>可以通过Vue.set()和Vue.delete()来实现的</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝浅拷贝</title>
      <link href="/2022/04/27/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/04/27/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h3><p>浅拷贝分为基本数据类型拷贝和引用类型拷贝</p><p>基本数据类型拷贝：拷贝的只是表层的数据</p><p>引用类型拷贝：复制的是内存地址，当修改复制过来的数据时，原数据也会修改</p><p>直接复制不是浅拷贝</p><p>深拷贝：不仅复制了数据还单独开辟了一块内存地址，当修改复制过来的数据的时候，原数据不会被改变</p><h4 id="数组深拷贝的方法："><a href="#数组深拷贝的方法：" class="headerlink" title="数组深拷贝的方法："></a>数组深拷贝的方法：</h4><h6 id="1-通过slice方法"><a href="#1-通过slice方法" class="headerlink" title="1. 通过slice方法"></a>1. 通过slice方法</h6><p>​slice()操作数组时，不会对原数组有影响，会产出一个新的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">42</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1.<span class="title function_">slice</span>()</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">// [1, 42, 5, 6]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2) <span class="comment">// [100, 42, 5, 6]</span></span><br></pre></td></tr></table></figure><p>数组arr2的改变未引起arr1的变化</p><h6 id="2-通过concat方法"><a href="#2-通过concat方法" class="headerlink" title="2.通过concat方法"></a>2.通过<a href="https://so.csdn.net/so/search?q=concat&spm=1001.2101.3001.7020">concat</a>方法</h6><p>数组的concat()方法，能够连接两个数组，同样不会改变原来的数组。用一个空数组连接另一个数组，即可实现深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;pig&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> arr4 = [].<span class="title function_">concat</span>(arr3)</span><br><span class="line">arr3[<span class="number">2</span>] = <span class="string">&#x27;big pig&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3) <span class="comment">// [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;big pig&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr4) <span class="comment">// [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;pig&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="3-通过ES6语法中-…"><a href="#3-通过ES6语法中-…" class="headerlink" title="3.通过ES6语法中 …"></a>3.通过ES6语法中 …</h6><p>ES6语法中的 …， 我经常在数组的深拷贝中用到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr5 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> arr6 = [...arr5]</span><br><span class="line">arr5[<span class="number">0</span>] = <span class="number">10000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr5) <span class="comment">// [10000, 0, 1]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr6) <span class="comment">// [0, 0, 1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="4-通过Array-from方法"><a href="#4-通过Array-from方法" class="headerlink" title="4.通过Array.from方法"></a>4.通过Array.from方法</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr7 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr8 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr7)</span><br><span class="line">arr7[<span class="number">1</span>] = <span class="number">1000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr7) <span class="comment">// [1, 1000, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr8) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="对象深拷贝的方法："><a href="#对象深拷贝的方法：" class="headerlink" title="对象深拷贝的方法："></a>对象深拷贝的方法：</h4><h6 id="1-通过Object-assign-方法"><a href="#1-通过Object-assign-方法" class="headerlink" title="1. 通过Object.assign()方法"></a>1. 通过Object.assign()方法</h6><p>ES6的Object.assign() Object.assign(target, …sources)用于对象的合并，将源对象中的所有可枚举属性，复制到目标对象中，并返回合并后的目标对象。后来的源对象的属性值，将会覆盖它之前的对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xia&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">160</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> otherPerson = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, person)</span><br><span class="line">person.<span class="property">age</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherPerson)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="万能转换器（对Array和Object等都适用）"><a href="#万能转换器（对Array和Object等都适用）" class="headerlink" title="万能转换器（对Array和Object等都适用）"></a>万能转换器（对Array和Object等都适用）</h5><p>前面讲解了 Array和Object的深拷贝方法，但是对于有更深层次的结构关系（数组套数组 数组套对象 对象套对象等），上面的方法就失灵了。</p><p>万能转换器 JSON.parse(JSON.stringify(obj))深拷贝已有对象，它可以深拷贝多层级的，不用担心嵌套问题</p><h4 id="JSON-stingify-obj-将js中的对象转换成JSON字符串"><a href="#JSON-stingify-obj-将js中的对象转换成JSON字符串" class="headerlink" title="JSON.stingify(obj)将js中的对象转换成JSON字符串"></a>JSON.stingify(obj)将js中的对象转换成JSON<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jack = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jack)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(jack))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="JSON-parse-将json字符串解析成对象"><a href="#JSON-parse-将json字符串解析成对象" class="headerlink" title="JSON.parse()将json字符串解析成对象"></a>JSON.parse()将json字符串解析成对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;qinxi&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj: &#x27;</span>, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;json string: &#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------------&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str to obj: &#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str))</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deeClone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="comment">//如果是值类型或null,则直接return</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">typeof</span>(obj) !== <span class="string">&#x27;object&#x27;</span> || obj ===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义结果对象</span></span><br><span class="line">    <span class="keyword">let</span> copy = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果对象是数组，则定义结果数组</span></span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="property">constructor</span> === <span class="title class_">Array</span>) &#123;</span><br><span class="line">        copy = []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历对象的key</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="comment">//如果key是对象的自有属性</span></span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">            <span class="comment">//递归调用深拷贝方法</span></span><br><span class="line">            copy[key] = <span class="title function_">deepClone</span>(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟DOM和diff算法</title>
      <link href="/2022/04/27/%E8%99%9A%E6%8B%9FDOM%E5%92%8Cdiff%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/27/%E8%99%9A%E6%8B%9FDOM%E5%92%8Cdiff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="什么时虚拟DOM？"><a href="#什么时虚拟DOM？" class="headerlink" title="什么时虚拟DOM？"></a>什么时虚拟DOM？</h3><p>虚拟dom使用js模拟dom结构，计算出最小的变更，操作dom,数据驱动试图的模式下，有效控制dom操作。</p><p>虚拟dom实际上就是一个js对象，用来描述真实dom,如果操作中多次更新dom的操作，会用diff算法进行对比，根据新内容生成一个新的虚拟dom,最终把这个虚拟DOM一次性attch到DOM树上，这样节省了性能。</p><h4 id="为什么要创建虚拟dom"><a href="#为什么要创建虚拟dom" class="headerlink" title="为什么要创建虚拟dom?"></a><strong>为什么要创建虚拟dom?</strong></h4><p>创建真实DOM成本比较高，如果用 js对象来描述一个dom节点，成本比较低，另外我们在频繁操作dom是一种比较大的开销。所以建议用虚拟dom来描述真实dom。</p><h4 id="虚拟DOM的作用？"><a href="#虚拟DOM的作用？" class="headerlink" title="虚拟DOM的作用？"></a>虚拟DOM的作用？</h4><p>维护视图和状态的关系</p><p>复杂视图情况下提升渲染性能</p><p>除了渲染dom以外，还可以实现SSR(服务器端渲染)、原生应用（Weex&#x2F;React Native）、小程序（uni-app）等</p><h4 id="Diff算法的步骤："><a href="#Diff算法的步骤：" class="headerlink" title="Diff算法的步骤："></a>Diff算法的步骤：</h4><p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文 档当中<br>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异<br>把第二棵树所记录的差异应用到第一棵树所构建的真正的DOM树上(patch)，视图就更新了</p><p><img src="/2022/04/27/%E8%99%9A%E6%8B%9FDOM%E5%92%8Cdiff%E7%AE%97%E6%B3%95/f10c5764908046c08b172f6a50d7c374.png"></p>]]></content>
      
      
      <categories>
          
          <category> Dom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化-防抖+节流</title>
      <link href="/2022/04/27/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81/"/>
      <url>/2022/04/27/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>防抖：是指事件触发几秒之后执行回调，如果几秒之内又触发了事件，则重新计算时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> &gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,delay=<span class="number">500</span></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="title function_">cleartimerout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="title function_">setTimout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> input1 = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(input)</span><br><span class="line"></span><br><span class="line">input1[<span class="number">0</span>].<span class="property">oninput</span> = <span class="title function_">debouce</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(input1[<span class="number">0</span>].<span class="property">value</span>)</span><br><span class="line">&#125;,<span class="number">600</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要应用场景有：<br>a、scroll事件滚动触发，<br>b、搜索框输入查询<br>c、表单验证<br>d、按钮提交事件<br>e、浏览器窗口缩放，resize事件</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流：频繁的触发事件，在n秒执行一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;节流&quot;</span> &gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,delay=<span class="number">200</span></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> newDate = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">        <span class="keyword">if</span>(newDate-timer&gt;delay)&#123;</span><br><span class="line">            timer = newDate</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jieLiu = <span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">jieliu[<span class="number">0</span>].<span class="property">onclicek</span> = <span class="title function_">throttle</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">&#125;,<span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>主要应用场景：<br>a、DOM元素的拖拽功能实现<br>b、射击游戏类<br>c、计算鼠标移动的距离<br>d、监听scroll事件</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识点</title>
      <link href="/2022/04/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/04/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="eventLoop事件循环？"><a href="#eventLoop事件循环？" class="headerlink" title="eventLoop事件循环？"></a>eventLoop事件循环？</h3><p>我们都知道JavaScript代码是从上向下执行的，但是它会分为同步任务和异步任务，同步任务会依次执行，但是遇到异步任务的话，会将异步任务放到任务队列中，执行完同步任务之后，事件循环会从任务队列中，将异步任务调出执行，会先执行宏任务中的微任务，在执行宏任务。</p><h3 id="宏任务和微任务？"><a href="#宏任务和微任务？" class="headerlink" title="宏任务和微任务？"></a>宏任务和微任务？</h3><p>宏任务：是由宿主发起的 包含：setTimeout，script，setInterval,I&#x2F;O,setImmdate</p><p>微任务：由JavaScript自身发起的 包含：promise, object.observe(已废弃，proxy代替), process.nextTick</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>promise是解决异步编程的一种解决方案，比传统的回调函数更加强大，更加合理</p><p><strong>promise特点</strong>：</p><p>对象不受外界的的影响，并且promise有三个状态有进行中，成功，错误。异步操作的结果，可以决定是哪一种状态，其他操作都无法改变</p><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果，promise的状态改变只有两种可能一种是成功，一种是失败</p><p>如果要使用promise必须还要对promise实例化，实例化之后promise内还有一个回调函数，这个函数利有两个参数，分别是resolve和reject,当我们的状态发生改变的时候，如果成功会通过resolve返回成功的结果，如果失败会通过reject返回失败的结果，我们也可以通过.then的方法接受返回的是成功的结果，catch接收返回失败的结果</p><p>promise常用的方法还有promise.all()的方法就是数组里面的数据全部为true才可以，</p><p>在项目中我们一般使用promise来对api接口进行封装，以及一些异步操作</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async await?"></a>async await?</h3><p>async函数，是Generator函数的语法糖，它建立在promise上，并且与现在的基于promise的API兼容</p><p>a:async 声明一个异步函数</p><p>自动将常规函数转换为promise,返回值也是一个promise对象</p><p>只有async函数内部的异步操作执行完，才会执行then方法指定回调函数</p><p>异步函数内部可以使用await</p><p>b:await可以暂停异步的功能执行</p><p>放置在promise调用之前，await强制其他代码等待，知道promise完成并返回结果</p><p>只能与promise一起使用，不适用与回调</p><p>只能在async函数内部使用</p><h3 id="async-await-相比于promise的优势？"><a href="#async-await-相比于promise的优势？" class="headerlink" title="async await 相比于promise的优势？"></a>async await 相比于promise的优势？</h3><p>代码读起来比promise更加同步，promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担</p><p>promise传递中间值非常麻烦，而async await 几乎是同步的写法，非常优雅</p><p>错误处理友好，async await可以用成熟的try catch ,promise的错误捕获非常冗余</p><p>调试友好</p><h3 id="简述同步和异步的区别"><a href="#简述同步和异步的区别" class="headerlink" title="简述同步和异步的区别"></a>简述同步和异步的区别</h3><p>同步：</p><p>浏览器访问服务器的请求，用户可以看到页面刷新，重新请求，请求完之后，页面刷新，新内容出现，用户看到新内容，再进行下一步操作</p><p>代码从上向下一次执行，执行完当前代码，才嫩根治性下面代码</p><p>异步：</p><p>浏览器访问服务器，用户正常操作，浏览器后端进行请求，等请求完之后，页面不刷新，新内容也会出现，用户看到新内容</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios?"></a>axios?</h3><p>axios是基于promise的HTTP库，可以用在浏览器和Node.js中。</p><p>为什么可以即在浏览器中使用也可以在Node.js中使用？</p><p>在浏览器中使用xmlHttpRequests发起请求</p><p>在node.js中使用http发起请求</p><p>原理：</p><p>通过xmlHttpResquest对象来向后端发起请求</p><h3 id="ajax？"><a href="#ajax？" class="headerlink" title="ajax？"></a>ajax？</h3><p>ajax就是异步的JavaScript和xml，前后端交互的基础</p><p>优点：</p><p>在不重新加载页面的情况下，可以与后端服务器交换数据，并更新部分网页无内容</p><p>原理：</p><p>在用户和服务器之间加了一个中间层（AJAX）,通过xmlHttpRequest对象来向服务器发送异步请求</p><p>从服务器获取数据，然后再用JavaScript来操作DOM而更新页面，使用户操作和服务器响应异步化，最关键的一步就是从服务器获取数据</p><h3 id="JavaScript垃圾回收机制？"><a href="#JavaScript垃圾回收机制？" class="headerlink" title="JavaScript垃圾回收机制？"></a>JavaScript垃圾回收机制？</h3><p>z在JavaScript中，如果一个对象不被引用，那么这个对象将被回收</p><p>如果两个对象相互引用，不再被第三者引用，那么这两个对象将被回收</p><p>垃圾回收机制：执行环境负责管理代码执行过程中使用的内存，js的垃圾回收机制是为了以防内存泄漏，就是间歇的不定期的寻找不再使用的变量，并释放掉他们所指向的内存</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http和https</title>
      <link href="/2022/04/27/httpAndhttps/"/>
      <url>/2022/04/27/httpAndhttps/</url>
      
        <content type="html"><![CDATA[<h3 id="一：http和https是什么"><a href="#一：http和https是什么" class="headerlink" title="一：http和https是什么?"></a>一：http和https是什么?</h3><p>http是超文本传输协议，是互联网上应用最为广泛的一种网络协议，是客户端和服务端请求和应答的标准（TCP）,用于www服务器传输超文本道本地浏览器的传输协议，它可以使浏览器更高效，使网络传输更少</p><p>https:是以安全为目标的HTTP的通道，简单讲使HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础就是SSL</p><p>作用主要使：建立一个信息安全通道，来确保数组的传输，确保网站的真实性</p><h4 id="（2）：http和https的区别？"><a href="#（2）：http和https的区别？" class="headerlink" title="（2）：http和https的区别？"></a>（2）：http和https的区别？</h4><p>http:传输的数据是未加密的，明文进行传输，不安全。端口号为80，连接是无状态的</p><p>https:传输的数据是加密的，具有安全性。端口号为443</p><h4 id="（3）：https协议的工作原理"><a href="#（3）：https协议的工作原理" class="headerlink" title="（3）：https协议的工作原理"></a>（3）：https协议的工作原理</h4><p>1:客户使用https的url访问web服务器，要求与web服务器建立SSL链接</p><p>2：web服务器收到客户端请后，会将网站的证书信息（证书中包含公钥）传送一份给客户端</p><p>3：客户端的浏览器与web服务器开始协商ssl&#x2F;tls连接的安全等级，也就是信息加密的等级</p><p>4：客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>5：web服务器利用自己的私钥解密出会话密钥</p><p>6：web服务器利用会话密钥加密与客户端之间的通信</p><h4 id="（4）：http的工作原理"><a href="#（4）：http的工作原理" class="headerlink" title="（4）：http的工作原理"></a>（4）：http的工作原理</h4><p>1：客户与服务器建立连接；</p><p>2：客户向服务器提出请求；</p><p>3：服务器接受请求，并根据请求返回相应的文件作为应答；</p><p>4：客户与服务器关闭连接。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack tree-shaking</title>
      <link href="/2022/04/27/webpack-tree-shaking/"/>
      <url>/2022/04/27/webpack-tree-shaking/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Tree-shaking"><a href="#什么是Tree-shaking" class="headerlink" title="什么是Tree-shaking?"></a><strong>什么是Tree-shaking?</strong></h3><p>tree-shaking:树摇，打包中去除哪些引入了但是在代码中没有用到的死码，在webpack中js treesharking通过UglifyJSPlugin来进行，css中通过purify-CSS来进行</p><p>tree-sharking针对的是纯的ES模块，才能去除掉那些未使用的代码或成员以及导入的其他模块</p><span id="more"></span><h4 id="什么是纯的ES模块？"><a href="#什么是纯的ES模块？" class="headerlink" title="什么是纯的ES模块？"></a>什么是纯的ES模块？</h4><p>纯ES模块内部或其内部成员不依赖于其他ES模块</p><p>纯ES模块不导入其他非ES模块</p><p>纯ES模块除了导入和导出，没有多余的代码</p><p><strong>作用：减少代码体积</strong></p><p><strong>摇树要不干净怎么解决？</strong></p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606152124154-2140837737.png"></p><p>test.js 中定义了 通过 ES6 模块 暴露了 add 和 count 两个方法，</p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606152836757-2013439339.png">}</p><p>index.js 中 引入了 add 和 count 方法，但是 count 方法的返回值没有使用</p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606153338606-64208927.png"></p><p>![](.&#x2F;webpack-tree-shaking&#x2F;1743698-20200606152257098-494028917 (1).png)</p><p>文件中引入了方法，但是方法的返回值没有使用，webpack编译打包后的js文件中，没有方法的执行，自动去除了没有使用的代码，</p><p>当在package.json中配置“sideEffects”:false时，所有的代码都可以进行tree-sharking,都没有副作用</p><p>但是可能会把css&#x2F;@babel&#x2F;polyfill (副作用)文件去除，</p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606153449160-121978646.png"></p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606152257098-494028917.png"></p><p>避免这种情况，需要重新配置，“sideEffects”:[“<em>.css”,”</em>.less”],过滤这些文件使用tree shaking</p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606153835043-129962384.png"></p><p><img src="/2022/04/27/webpack-tree-shaking/1743698-20200606154016482-466219622.png"></p><p>css文件就保存了</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack_优化</title>
      <link href="/2022/04/27/webpack-%E4%BC%98%E5%8C%96/"/>
      <url>/2022/04/27/webpack-%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack优化：（开发环境和生产环境）"><a href="#webpack优化：（开发环境和生产环境）" class="headerlink" title="webpack优化：（开发环境和生产环境）"></a>webpack优化：（开发环境和生产环境）</h2><h2 id="首先要知道为什么要优化webpack？"><a href="#首先要知道为什么要优化webpack？" class="headerlink" title="首先要知道为什么要优化webpack？"></a>首先要知道为什么要优化webpack？</h2><p>在使用Webpack时，如果不注意性能优化，有非常大的可能会产生性能问题，性能问题主要分为开发时打包构建速度慢、开发调试时的重复性工作、以及输出文件质量不高等，因此性能优化也主要从这些方面来分析。</p><p>​不就是因为在开发阶段可以及时的编译和浏览器实时刷新页面知道最新的内容嘛，   但是如果说模块很多的话  刷新页面这个方案很是不好，加载很慢。</p><h2 id="开发环境优化："><a href="#开发环境优化：" class="headerlink" title="开发环境优化："></a>开发环境优化：</h2><h3 id="优化打包构建速度-HMR"><a href="#优化打包构建速度-HMR" class="headerlink" title="优化打包构建速度 HMR"></a>优化打包构建速度 HMR</h3><p>​HMR 全称 Hot Module Replacement，中文语境通常翻译为模块热更新，它能够在保持页面状态的情况下动态替换资源模块，提供丝滑顺畅的 Web 页面开发体验。</p><span id="more"></span><p>​所以说有一个HMR（热更新，热模块）这个可以让你实时的监听你的文件变化从而达到替换小一部分dom</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="comment">// 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效</span></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./print.js&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。</span></span><br><span class="line">    <span class="comment">// 会执行后面的回调函数</span></span><br><span class="line">    <span class="title function_">print</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化代码调试source-map"><a href="#优化代码调试source-map" class="headerlink" title="优化代码调试source-map"></a>优化代码调试source-map</h3><p>​再思考一个问题 webpack最后打包生成的bundle聚集了所有的代码，如果说其中有一行代码出错了 你是想精准的定位到哪一行还是说不让其有报错</p><p>​设置sourcemap中的属性可以有很多种模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  source-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置</span></span><br><span class="line"><span class="comment">    inline-source-map：内联</span></span><br><span class="line"><span class="comment">      只生成一个内联source-map</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置</span></span><br><span class="line"><span class="comment">    hidden-source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码错误原因，但是没有错误位置</span></span><br><span class="line"><span class="comment">      不能追踪源代码错误，只能提示到构建后代码的错误位置</span></span><br><span class="line"><span class="comment">    eval-source-map：内联</span></span><br><span class="line"><span class="comment">      每一个文件都生成对应的source-map，都在eval</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置</span></span><br><span class="line"><span class="comment">    nosources-source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码准确信息, 但是没有任何源代码信息</span></span><br><span class="line"><span class="comment">    cheap-source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置 </span></span><br><span class="line"><span class="comment">      只能精确的行</span></span><br><span class="line"><span class="comment">    cheap-module-source-map：外部</span></span><br><span class="line"><span class="comment">      错误代码准确信息 和 源代码的错误位置 </span></span><br><span class="line"><span class="comment">      module会将loader的source map加入</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    开发环境：速度快，调试更友好</span></span><br><span class="line"><span class="comment">      速度快(eval&gt;inline&gt;cheap&gt;...)</span></span><br><span class="line"><span class="comment">        eval-cheap-souce-map</span></span><br><span class="line"><span class="comment">        eval-source-map</span></span><br><span class="line"><span class="comment">      调试更友好  </span></span><br><span class="line"><span class="comment">        souce-map</span></span><br><span class="line"><span class="comment">        cheap-module-souce-map</span></span><br><span class="line"><span class="comment">        cheap-souce-map</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      --&gt; eval-source-map  / eval-cheap-module-souce-map</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    生产环境：源代码要不要隐藏? 调试要不要更友好</span></span><br><span class="line"><span class="comment">      内联会让代码体积变大，所以在生产环境不用内联</span></span><br><span class="line"><span class="comment">      nosources-source-map 全部隐藏</span></span><br><span class="line"><span class="comment">      hidden-source-map 只隐藏源代码，会提示构建后代码错误信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      --&gt; source-map / cheap-module-souce-map</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="生产环境中："><a href="#生产环境中：" class="headerlink" title="生产环境中："></a>生产环境中：</h1><h2 id="优化打包构建速度"><a href="#优化打包构建速度" class="headerlink" title="优化打包构建速度"></a>优化打包构建速度</h2><h3 id="oneOf："><a href="#oneOf：" class="headerlink" title="oneOf："></a>oneOf：</h3><p>提升构建速度，避免每个文件都被所有<code>loader</code>过一遍，因为任何一个文件，构建过程中，在遇到第一个与之对应的<code>loader</code>后，不会再往下进行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">oneOf</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;html-loader&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;eslint-loader&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>但是，实际开发过程中，同样会有一个文件需要匹配多个<code>loader</code>的场景，比如<code>js</code>文件同时需要<code>eslint-loader</code>和<code>babel-loader</code>，这样的话就不能将两个<code>loader</code>都放到<code>oneOf</code>里面，因为一旦匹配了第一个<code>loader</code>就不会再继续执行第二个<code>loader</code>，解决办法也很简单，只需要放到<code>oneOf</code>外面即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">enforce</span>: <span class="string">&quot;pre&quot;</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;eslint-loader&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">oneOf</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;html-loader&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="babel缓存："><a href="#babel缓存：" class="headerlink" title="babel缓存："></a>babel缓存：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  缓存：</span></span><br><span class="line"><span class="comment">    babel缓存</span></span><br><span class="line"><span class="comment">      cacheDirectory: true</span></span><br><span class="line"><span class="comment">      --&gt; 让第二次打包构建速度更快</span></span><br><span class="line"><span class="comment">    文件资源缓存</span></span><br><span class="line"><span class="comment">      hash: 每次wepack构建时会生成一个唯一的hash值。</span></span><br><span class="line"><span class="comment">        问题: 因为js和css同时使用一个hash值。</span></span><br><span class="line"><span class="comment">          如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）</span></span><br><span class="line"><span class="comment">      chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样</span></span><br><span class="line"><span class="comment">        问题: js和css的hash值还是一样的</span></span><br><span class="line"><span class="comment">          因为css是在js中被引入的，所以同属于一个chunk</span></span><br><span class="line"><span class="comment">      contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样    </span></span><br><span class="line"><span class="comment">      --&gt; 让代码上线运行缓存更好使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">                <span class="attr">presets</span>: [</span><br><span class="line">                    [</span><br><span class="line">                        <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">                            <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">                            <span class="attr">targets</span>: &#123;</span><br><span class="line">                                <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                                <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                ],</span><br><span class="line">                <span class="comment">// 开启babel缓存</span></span><br><span class="line">                <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">                <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            <span class="attr">use</span>: [</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                开启多进程打包。 </span></span><br><span class="line"><span class="comment">                进程启动大概为600ms，进程通信也有开销。</span></span><br><span class="line"><span class="comment">                只有工作消耗时间比较长，才需要多进程打包</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">workers</span>: <span class="number">2</span> <span class="comment">// 进程2个</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">presets</span>: [</span><br><span class="line">                            [</span><br><span class="line">                                <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">                                    <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">                                    <span class="attr">targets</span>: &#123;</span><br><span class="line">                                        <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                                        <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="comment">// 开启babel缓存</span></span><br><span class="line">                        <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">                        <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">externals</span>: &#123;</span><br><span class="line">  <span class="comment">// 拒绝jQuery被打包进来</span></span><br><span class="line">  <span class="attr">jquery</span>: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要引用一个库，但是又不想让webpack打包（减少打包的时间），并且又不影响我们在程序中以<a href="https://so.csdn.net/so/search?q=CMD&spm=1001.2101.3001.7020">CMD</a>、AMD或者window&#x2F;global全局等方式进行使用（一般都以import方式引用使用），那就可以通过配置externals。</p><p>这样做的目的就是<strong>将不怎么需要更新的第三方库脱离webpack打包，不被打入bundle中，从而减少打包时间，但又不影响运用第三方库的方式，例如import方式等。</strong></p><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><ul><li><p>什么是DLL</p><ul><li>DLL全称是动态链接库(Dynamic Link Library)，是为软件在Windows中实现共享函数库的一种实现方式;</li><li>那么webpack中也有内置DLL的功能，它指的是可以将可以共享，并且不经常改变的代码，抽取成一个共享的库;</li><li>这个库在之后编译的过程中，会被引入到其他项目的代码中，减少的打包的时间;</li></ul></li><li><p>DDL库的使用分为两步:</p><ul><li><p>第一步:打包一个DLL库; </p><p><strong>webpack –config webpack.dll.js</strong></p></li><li><p>第二步:项目中引入DLL库</p><p><strong>webpack</strong></p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.js</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包</span></span><br><span class="line"><span class="comment">    当你运行 webpack 时，默认查找 webpack.config.js 配置文件</span></span><br><span class="line"><span class="comment">    需求：需要运行 webpack.dll.js 文件</span></span><br><span class="line"><span class="comment">      --&gt; webpack --config webpack.dll.js</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="comment">// 最终打包生成的[name] --&gt; jquery</span></span><br><span class="line">    <span class="comment">// [&#x27;jquery&#x27;] --&gt; 要打包的库是jquery</span></span><br><span class="line">    <span class="attr">jquery</span>: [<span class="string">&#x27;jquery&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dll&#x27;</span>),</span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span> <span class="comment">// 打包的库里面向外暴露出去的内容叫什么名字</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 打包生成一个 manifest.json --&gt; 提供和jquery映射</span></span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>, <span class="comment">// 映射库的暴露的内容名称</span></span><br><span class="line">      <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>) <span class="comment">// 输出文件路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AddAssetHtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 告诉webpack哪些库不参与打包，同时使用时的名称也得变~</span></span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">      <span class="attr">manifest</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 将某个文件打包输出去，并在html中自动引入该资源</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AddAssetHtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filepath</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dll/jquery.js&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="优化代码运行的性能"><a href="#优化代码运行的性能" class="headerlink" title="优化代码运行的性能"></a>优化代码运行的性能</h2><h3 id="缓存-hash-chunkhash-contenthash"><a href="#缓存-hash-chunkhash-contenthash" class="headerlink" title="缓存(hash-chunkhash-contenthash)"></a>缓存(hash-chunkhash-contenthash)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash</span>: 每次wepack构建时会生成一个唯一的hash值。</span><br><span class="line">  问题: 因为js和css同时使用一个hash值。</span><br><span class="line">    如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）</span><br><span class="line">chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样</span><br><span class="line">  问题: js和css的hash值还是一样的</span><br><span class="line">    因为css是在js中被引入的，所以同属于一个chunk</span><br><span class="line"><span class="attr">contenthash</span>: 根据文件的内容生成hash值。不同文件hash值一定不一样 </span><br></pre></td></tr></table></figure><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  tree shaking：去除无用代码</span></span><br><span class="line"><span class="comment">    前提：1. 必须使用ES6模块化  2. 开启production环境</span></span><br><span class="line"><span class="comment">    作用: 减少代码体积</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在package.json中配置 </span></span><br><span class="line"><span class="comment">      &quot;sideEffects&quot;: false 所有代码都没有副作用（都可以进行tree shaking）</span></span><br><span class="line"><span class="comment">        问题：可能会把css / @babel/polyfill （副作用）文件干掉</span></span><br><span class="line"><span class="comment">      &quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="code-split"><a href="#code-split" class="headerlink" title="code split"></a>code split</h3><p>当使用 webpack 打包 JavaScript 文件的时候，依赖了第三方库，比如 有两个入口：testa，testb，  都依赖了 jQuery，jQuery就会被打包到这两个文件中，显然这是不太合理的，应该是 jQuery 单独打包一个文件，然后 testa 和 testb 分别引入。</p><p>方式一：</p><p>通过配置多入口，打包成多个文件</p><p>方式二：</p><p>动态引入 (dynamic import) JavaScript 文件必然会单独打包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 /*webpackChunkName:lodash*/ 给构建出的chunk命名，否则会以构建id命名。</span></span><br><span class="line"><span class="title function_">import</span>(<span class="comment">/*webpackChunkName:&#x27;lodash&#x27;*/</span><span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(params) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 导入成功</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="string">&#x27;An error occurred while loading the component&#x27;</span>); </span><br></pre></td></tr></table></figure><p>方式三：</p><p>配置webpack的code split  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/index.js&#x27;</span>),</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> webpack.<span class="title class_">HashedModuleIdsPlugin</span>() <span class="comment">// 根据模块的相对路径生成 HASH 作为模块 ID</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">runtimeChunk</span>: <span class="string">&#x27;single&#x27;</span>,</span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">// 默认 async 可选值 all 和 initial</span></span><br><span class="line">            <span class="attr">maxInitialRequests</span>: <span class="title class_">Infinity</span>, <span class="comment">// 一个入口最大的并行请求数</span></span><br><span class="line">            <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 避免模块体积过小而被忽略</span></span><br><span class="line">            <span class="attr">minChunks</span>: <span class="number">1</span>, <span class="comment">// 默认也是一表示最小引用次数</span></span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">                <span class="attr">vendor</span>: &#123;</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 如果需要的依赖特别小，可以直接设置成需要打包的依赖名称</span></span><br><span class="line">                    <span class="title function_">name</span>(<span class="params"><span class="variable language_">module</span>, chunks, chcheGroupKey</span>) &#123; <span class="comment">// 可提供布尔值、字符串和函数，如果是函数，可编写自定义返回值</span></span><br><span class="line">                        <span class="keyword">const</span> packageName = <span class="variable language_">module</span>.<span class="property">context</span>.<span class="title function_">match</span>(<span class="regexp">/[\\/]node_modules[\\/](.*?)([\\/]|$)/</span>)[<span class="number">1</span>] <span class="comment">// 获取模块名称</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">`npm.<span class="subst">$&#123;packageName.replace(<span class="string">&#x27;@&#x27;</span>, <span class="string">&#x27;&#x27;</span>)&#125;</span>`</span> <span class="comment">// 可选，一般情况下不需要将模块名称 @ 符号去除</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒加载-x2F-预加载"><a href="#懒加载-x2F-预加载" class="headerlink" title="懒加载&#x2F;预加载"></a>懒加载&#x2F;预加载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒加载~：当文件需要使用时才加载~</span></span><br><span class="line"><span class="comment">// 预加载 prefetch：会在使用之前，提前加载js文件 </span></span><br><span class="line"><span class="comment">// 正常加载可以认为是并行加载（同一时间加载多个文件）  </span></span><br><span class="line"><span class="comment">// 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源   </span></span><br><span class="line"><span class="comment">// 魔法注释 webpackPrefetch: true  开启预加载</span></span><br><span class="line"><span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27;, webpackPrefetch: true */</span><span class="string">&#x27;./test&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mul</span>(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端打包工具</title>
      <link href="/2022/04/27/%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/04/27/%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack，grunt-gulp-vite-fis3-Rollup-Pacel？"><a href="#webpack，grunt-gulp-vite-fis3-Rollup-Pacel？" class="headerlink" title="webpack，grunt,gulp,vite,fis3,Rollup,Pacel？"></a>webpack，grunt,gulp,vite,fis3,Rollup,Pacel？</h2><p><strong>webpack:</strong></p><p>就目前而言，weboack是最常用的打包工具，基于入口，webpack会自动递归解析入口所需要的所有资源，然后不同的loader处理不同的文件，用plugin来扩展webpack功能</p><p><strong>gulp:</strong></p><span id="more"></span><p>gulp是前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task.自动化构建工具并不能把所有的模块打包，也不能构建不同模块之间的依赖关系</p><p><strong>grunt:</strong></p><p>基于任务和流的，类似于jQuery,找到一个文件，对其做 一系列的链式操作，更新流上的数据，整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程</p><p><strong>Rollup:</strong></p><p>是一款ES Modules打包器，从作用上来看，Rollup与webpack非常类似，不过相比于webpack，Rollup要小巧的多，专门打包js</p><p>我们熟知的库都是用他进行打包，比如：vue,react等</p><p><strong>Parcel:</strong></p><p>是一款完全零配置的前端打包器，它提供了傻瓜式的使用体验，只需要了解简单的命令，就能构建前端应用程序</p><p>Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用 HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。</p><p><strong>vite:</strong></p><p>是vue作者尤雨溪开发的web开发构建工具，基于浏览器原生es模块导入的开发服务器，在开发环境下，利用浏览器去解析import,在服务器按需编译返回，完全跳过打包的概念，服务器随启随用，同时不仅对vue提供了支持，还支持热更新，热更新的速度不会随着模块增多而变慢。</p><p>特点：- 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译</p><p><strong>fis3:</strong></p><p>百度研发的，静态资源动态按需加载。</p><h4 id="webpack-Rollup-Pacel区别？"><a href="#webpack-Rollup-Pacel区别？" class="headerlink" title="webpack Rollup Pacel区别？"></a>webpack Rollup Pacel区别？</h4><table><thead><tr><th>对比</th><th>Webpack</th><th>Rollup</th><th>Parcel</th></tr></thead><tbody><tr><td>功能</td><td>为处理资源管理和分割代码而生，可以用来处理任何类型的文件，灵活，插件多。</td><td>用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。</td><td>用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。</td></tr><tr><td>配置</td><td>webpack需要配config文件，指明entry, output, plugin，transformations。</td><td>rollup需要配config文件，指明entry, output, plugin，transformations。rollup 有对import&#x2F;export所做的node polyfills，webpack没有。rollup支持相对路径，而webpack没有，所以得使用</td><td>parcel则是完全开箱可用的，不用配置。</td></tr><tr><td>入口文件</td><td>webpack只支持js文件作为入口文件，如果要以其他格式的文件作为入口，比如html文件为入口，如要加第三方Plugin。</td><td>rollup可以用html作为入口文件，但也需要plugin，比如rollup-plugin-html-entry。</td><td>parcel可以用index.html作为入口文件，而且它会通过看index.html的script tag里包含的什么自己找到要打包生成哪些js文件。</td></tr><tr><td>transformations</td><td>transformations指的是把其他文件转化成js文件的过程，需要经过transformation才能够被打包。webpack使用Loaders来处理。</td><td>rollup使用plugins来处理。</td><td>parcel会自动去转换，当找到配置文件比如.babelrc, .postcssrc后就会自动转。</td></tr><tr><td>摇树优化</td><td>摇树优化是webpack的一大特性。需要1，用import&#x2F;export语法，2，在package.json中加副作用的入口，3，加上支持去除死代码的缩小器（uglifyjsplugin）。</td><td>rollup会统计引入的代码并排除掉那些没有被用到的。这使您可以在现有工具和模块的基础上构建，而无需添加额外的依赖项或膨胀项目的大小。</td><td>parcel不支持摇树优化。</td></tr><tr><td>dev server</td><td>webpack用webpack-dev-server。</td><td>rollup用rollup-plugin-serve和rollup-plugin-livereload共同作用。</td><td>parcel内置的有dev server</td></tr><tr><td>热更新</td><td>webpack的 wepack-dev-server支持hot模式。</td><td>rollup不支持hmr。</td><td>parcel有内置的hmr。</td></tr><tr><td>代码分割</td><td>webpack通过在entry中手动设置，使用CommonsChunkPlugin，和模块内的内联函数动态引入来做代码分割。</td><td>rollup有实验性的代码分割特性。它是用es模块在浏览器中的模块加载机制本身来分割代码的。需要把experimentalCodeSplitting 和 experimentalDynamicImport 设为true。</td><td>parcel支持0配置的代码分割。主要是通过动态improt。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端打包工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端打包工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack_proxy</title>
      <link href="/2022/04/27/webpack-proxy/"/>
      <url>/2022/04/27/webpack-proxy/</url>
      
        <content type="html"><![CDATA[<h4 id="Webpack-Proxy工作原理"><a href="#Webpack-Proxy工作原理" class="headerlink" title="Webpack Proxy工作原理"></a>Webpack Proxy工作原理</h4><p>webpack proxy，即webpack提供的代理服务，解决前端跨域的方法。</p><p>基本行为就是接收客户端发送的请求后转发给目标服务器、</p><p>其目的就是为了便于开发者在开发模式下解决跨域的问题。</p><p>想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server</p><h3 id="proxy工作原理："><a href="#proxy工作原理：" class="headerlink" title="proxy工作原理："></a>proxy工作原理：</h3><p>实质就是通过http-proxy-middleware这个http代理中间件，实现请求转发给目标服务器。</p><h3 id="跨域："><a href="#跨域：" class="headerlink" title="跨域："></a>跨域：</h3><span id="more"></span><p>在开发阶段，webpack-dev-server会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在localhost的一个端口上，而后端服务器又是运行在另一个地址上，所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端会出现跨域请求问题，</p><p>解决跨域，需要设置webpack proxy代理，</p><p>当本地发送请求的时候，代理服务器响应 该请求，并将请求转发到目标服务器，目标服务器响应数据后在将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>plugin</title>
      <link href="/2022/04/27/plugin/"/>
      <url>/2022/04/27/plugin/</url>
      
        <content type="html"><![CDATA[<h3 id="plugin是什么-x2F-作用？"><a href="#plugin是什么-x2F-作用？" class="headerlink" title="plugin是什么&#x2F;作用？"></a>plugin是什么&#x2F;作用？</h3><p>plugin是插件的意思，通常用于对某个现有的架构进行扩展。webpack整体的程序架构也是基于插件系统之上搭建的，plugin的目的在于解决loader无法实现的其他功能，比如打包优化、文件压缩等。</p><h3 id="常见的plugin"><a href="#常见的plugin" class="headerlink" title="常见的plugin?"></a>常见的plugin?</h3><ul><li>define-plugin定义环境变量</li><li>commons-weboack-plugin:提取公共代码</li><li>uglifyjs-webpack-plugin:通过UglifyES压缩es6代码</li><li>purgecss-webpack-plugin:擦除无用css</li><li>happypack:多线程处理打包</li><li>webpack-bundle-analyzer:打包分析</li><li>speed-measure-webpack-plugin:构建速度分析</li><li>html-webpack-plugin:为html文件引入的外部资源如script,link动态添加每次complie后的hash,防止引用缓存的外部文件问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack  Loader</title>
      <link href="/2022/04/27/loader/"/>
      <url>/2022/04/27/loader/</url>
      
        <content type="html"><![CDATA[<h3 id="loader是什么？"><a href="#loader是什么？" class="headerlink" title="loader是什么？"></a>loader是什么？</h3><p>webpack只能理解JavaScript和Json文件，这是webpack开箱可用的自带能力。</p><p>loader可以让webpack能够去处理其他类型的文件，比如.scss和.ts，并将他们转换为有效的功能离散的chunk文件以供 应用程序使用，以及被添加到依赖图中，也可以将内联图转换为data URL。简单来说：loader可以将一段代码转换成另一段代码。</p><p>loader从下到上取值，也就是从后往前执行，从ts-loader开始执行，然后继续执行css-loader,最后以raw-loader结束。</p><p>loader有两个属性：test,正则表达式，用于识别出哪些文件会被转换，</p><p>​                                use,定义在进行转换时应该使用哪个loader，可以是字符串，数组和对象。</p><span id="more"></span><h3 id="loader机制的作用是什么？"><a href="#loader机制的作用是什么？" class="headerlink" title="loader机制的作用是什么？"></a>loader机制的作用是什么？</h3><p>webpack只能理解JavaScript和Json文件，而loader为webpack添加了处理其他类型的文件的能力。</p><p>webpack在配置里的module.rules数组配置了一组规则，告诉webapck在遇到哪些文件时使用哪些loader去加载和转换打包成js。</p><h3 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h3><ul><li>file-loader:把文件输出到一个文件夹中，在代码中通过相对的URL去引用输出的文件</li><li>url-loader:和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中</li><li>source-map-loader:加载额外的Source Map文件，以方便断点调试</li><li><strong>image-loader:加载并压缩图片文件</strong></li><li><strong>babel-loader:把es6转换成es5</strong></li><li><strong>css-loader:加载css,支持模块化，压缩，文件导入等特性</strong></li><li><strong>style-loader:把css代码注入到JavaScript中，通过DOM操作去加载css</strong></li><li><strong>eslint-loader:通过eslint检查JavaScript代码</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack4和webpack5的区别</title>
      <link href="/2022/04/26/webpack4-5/"/>
      <url>/2022/04/26/webpack4-5/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack4和webpack5的区别？"><a href="#webpack4和webpack5的区别？" class="headerlink" title="webpack4和webpack5的区别？"></a>webpack4和webpack5的区别？</h2><h5 id="1、Tree-Shaking-强大"><a href="#1、Tree-Shaking-强大" class="headerlink" title="1、Tree Shaking(强大)"></a>1、Tree Shaking(强大)</h5><p>tree-shaking 就可以把没有用的那些东西剔除掉，来大大减少最终的bundle体积。</p><ul><li>usedExports : true, 标记没有用的叶子</li><li>minimize: true, 摇掉那些没有用的叶子</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js中</span></span><br><span class="line"></span><br><span class="line"> <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line"></span><br><span class="line">      <span class="attr">usedExports</span>: <span class="literal">true</span>, <span class="comment">//只导出被使用的模块</span></span><br><span class="line"></span><br><span class="line">      minimize : <span class="literal">true</span> <span class="comment">// 启动压缩</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="2-压缩代码"><a href="#2-压缩代码" class="headerlink" title="2.压缩代码"></a>2.压缩代码</h5><p>webpack4 上需要下载安装 terser-webpack-plugin 插件</p><p>webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js中</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"></span><br><span class="line">     <span class="attr">optimization</span>: &#123;</span><br><span class="line"></span><br><span class="line">       <span class="attr">usedExports</span>: <span class="literal">true</span>, <span class="comment">//只导出被使用的模块</span></span><br><span class="line"></span><br><span class="line">       minimize : <span class="literal">true</span> <span class="comment">// 启动压缩</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="3-缓存配置"><a href="#3-缓存配置" class="headerlink" title="3.缓存配置"></a>3.缓存配置</h5><p>webpack4 缓存配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install hard-source-webpack-plugin -D</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HardSourceWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;hard-source-webpack-plugin&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; </span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="comment">// 其它 plugin... </span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HardSourceWebpackPlugin</span>(), </span><br><span class="line">] &#125;</span><br></pre></td></tr></table></figure><p>webpack5 缓存配置</p><p>webpack5 内部内置了 cache 缓存机制。直接配置即可。</p><p>cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>= &#123;</span><br><span class="line">  <span class="comment">// 使用持久化缓存</span></span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;filesystem&#x27;</span>，</span><br><span class="line">    <span class="attr">cacheDirectory</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;node_modules/.cac/webpack&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-启动服务的差别"><a href="#4-启动服务的差别" class="headerlink" title="4.启动服务的差别"></a>4.启动服务的差别</h5><p>webpack4 启动服务<br>    通过 webpack-dev-server 启动服务</p><p>webpack5 启动服务<br>内置使用 webpack serve 启动，但是他的日志不是很好，所以一般喜欢用 webpack-dev-server 优化</p><h5 id="5-打包"><a href="#5-打包" class="headerlink" title="5.打包"></a>5.打包</h5><p>webpack4打包:即使后续没有使用到的函数，依然会将代码打包进去</p><p>webpack5打包:后续没有使用到的函数，不会将代码打包进去</p><h5 id="6-输出代码"><a href="#6-输出代码" class="headerlink" title="6.输出代码"></a>6.输出代码</h5><p>webpack4只能输出es5的代码</p><p>webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码</p><h5 id="7-分割代码块（splitChunk）"><a href="#7-分割代码块（splitChunk）" class="headerlink" title="7.分割代码块（splitChunk）"></a>7.分割代码块（splitChunk）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack4将超过30kb的文件单独提为一个chunk</span></span><br><span class="line"><span class="attr">minSize</span>: <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack5可以区分是js还是css,可以精确划分</span></span><br><span class="line"><span class="attr">minSize</span>:&#123;<span class="attr">javascript</span>:<span class="number">30000</span>,<span class="attr">css</span>:<span class="number">50000</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识webpack</title>
      <link href="/2019/04/14/webpack/"/>
      <url>/2019/04/14/webpack/</url>
      
        <content type="html"><![CDATA[<h4 id="webpack是什么？"><a href="#webpack是什么？" class="headerlink" title="webpack是什么？"></a>webpack是什么？</h4><p>webpack是前端资源加载&#x2F;打包的工具，他根据模块的依赖关系进行静态分析，然后根据指定的规则生成静态资源。</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>webapck可以将多种静态资源js,css,html等转换成一个静态文件，减少页面请求。</p><h4 id="核心概念："><a href="#核心概念：" class="headerlink" title="核心概念："></a>核心概念：</h4><p>1：entry:指定入口，打包的时候告诉webpack从哪个文件开始打包</p><p>2：output:指定出口，打包后的文件指定输出路径和文件名，将文件写入文件系统</p><p>3：loader:转换器，简单来说就是将一段代码转换成另一段代码，webpack只能解析JavaScript代码，将代码转换成webpack能解析的JavaScript</p><p>4：plugin:插件，可以用于范围更广的任务，完成loader不能完成的任务，比如代码优化和压缩等</p><p>5：mode：模式，null,development(开发模式)，production(生产模式)</p><span id="more"></span><h4 id="构建流程："><a href="#构建流程：" class="headerlink" title="构建流程："></a>构建流程：</h4><p>1：初始化参数：将配置文件和命令中的参数合并读取，将参数进行初始化，得到最终的参数</p><p>2：开始编译：得到最终的参数实例化complier对象，加载配置文件plugin,执行run方法进行编译</p><p>3：确定入口：从entry入口找到所有的入口文件，递归遍历所有的文件</p><p>4：编译模块：从入口文件出发，调用所有的配置loader对模块进行编译，模块找出依赖的模块，递归编译直到所有的文件都进行了编译</p><p>5：输出资源：所有的模块都编译完成，得到最终的输出资源，chunk</p><p>6：确定输出：将得到的最终资源，chunk,配置输出文件的路径和文件名，将文件输出文件系统</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
